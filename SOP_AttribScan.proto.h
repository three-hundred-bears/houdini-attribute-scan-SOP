/* Automagically Generated by generate_proto.py
 * Do not Edit
 */
#pragma once

#include <SOP/SOP_NodeVerb.h>
#include <SOP/SOP_GraphProxy.h>

#include <OP/OP_Utils.h>
#include <PRM/PRM_Parm.h>
#include <UT/UT_IStream.h>
#include <UT/UT_NTStreamUtil.h>
#include <UT/UT_Ramp.h>
#include <UT/UT_SharedPtr.h>
#include <UT/UT_StringHolder.h>
#include <UT/UT_StringStream.h>
#include <UT/UT_VectorTypes.h>
#include <UT/UT_EnvControl.h>
#include <SYS/SYS_Types.h>

using namespace UT::Literal;

class DEP_MicroNode;
namespace SOP_AttribScanEnums
{
    enum class Attribowner
    {
        VERTS = 0,
        POINTS,
        PRIMS,
        DETAIL
    };
    enum class Attribtype
    {
        FLOAT = 0,
        INT,
        STRING,
        VECTOR2,
        VECTOR,
        VECTOR4,
        MATRIX2,
        MATRIX3,
        MATRIX,
        DICT
    };
    enum class Method
    {
        PRESENCE = 0,
        ABSENCE
    };
}


class  SOP_AttribScanParms  : public SOP_NodeParms
{
public:
    static int version() { return 1; }
    struct RecognizedAttribs
    {
        UT_StringHolder attribname;
        int64 attribowner;
        int64 attribtype;
        bool ensurevalue;
        fpreal64 floatval;
        int64 intval;
        UT_StringHolder stringval;
        UT_Vector2D vector2val;
        UT_Vector3D vector3val;
        UT_Vector4D vector4val;
        int64 method;


        RecognizedAttribs()
        {
            attribname = ""_sh;
            attribowner = 0;
            attribtype = 0;
            ensurevalue = false;
            floatval = 0;
            intval = 0;
            stringval = ""_sh;
            vector2val = 0;
            vector3val = 0;
            vector4val = 0;
            method = 0;

        }

        bool operator==(const RecognizedAttribs &src) const
        {
            if (attribname != src.attribname) return false;
            if (attribowner != src.attribowner) return false;
            if (attribtype != src.attribtype) return false;
            if (ensurevalue != src.ensurevalue) return false;
            if (floatval != src.floatval) return false;
            if (intval != src.intval) return false;
            if (stringval != src.stringval) return false;
            if (vector2val != src.vector2val) return false;
            if (vector3val != src.vector3val) return false;
            if (vector4val != src.vector4val) return false;
            if (method != src.method) return false;

            return true;
        }
        bool operator!=(const RecognizedAttribs &src) const
        {
            return !operator==(src);
        }

    };

    UT_StringHolder createString(const UT_Array<RecognizedAttribs> &list) const
    {
        UT_WorkBuffer   buf;

        buf.strcat("[ ");
        for (int i = 0; i < list.entries(); i++)
        {
            if (i)
                buf.strcat(", ");
            buf.strcat("( ");
            buf.append("");
            { UT_String tmp; tmp = UT_StringWrap(list(i).attribname).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).attribowner);
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).attribtype);
            buf.append(", ");
            buf.appendSprintf("%s", (list(i).ensurevalue) ? "true" : "false");
            buf.append(", ");
            buf.appendSprintf("%f", (list(i).floatval));
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).intval);
            buf.append(", ");
            { UT_String tmp; tmp = UT_StringWrap(list(i).stringval).makeQuotedString('"'); buf.strcat(tmp); }
            buf.append(", ");
            buf.appendSprintf("(%f, %f)", list(i).vector2val.x(), list(i).vector2val.y());
            buf.append(", ");
            buf.appendSprintf("(%f, %f, %f)", list(i).vector3val.x(), list(i).vector3val.y(), list(i).vector3val.z());
            buf.append(", ");
            buf.appendSprintf("(%f, %f, %f, %f)", list(i).vector4val.x(), list(i).vector4val.y(), list(i).vector4val.z(), list(i).vector4val.w());
            buf.append(", ");
            buf.appendSprintf("%d", (int) list(i).method);

            buf.strcat(" )");
        }
        buf.strcat(" ]");

        UT_StringHolder result = buf;
        return result;
    }

    SOP_AttribScanParms()
    {
        myPtscan = ""_sh;
        myPrimscan = ""_sh;
        myVtxscan = ""_sh;
        myDtlscan = ""_sh;
        myRecognizedAttribs.setSize(1);

    }

    explicit SOP_AttribScanParms(const SOP_AttribScanParms &) = default;

    ~SOP_AttribScanParms() override {}

    bool operator==(const SOP_AttribScanParms &src) const
    {
        if (myPtscan != src.myPtscan) return false;
        if (myPrimscan != src.myPrimscan) return false;
        if (myVtxscan != src.myVtxscan) return false;
        if (myDtlscan != src.myDtlscan) return false;
        if (myRecognizedAttribs != src.myRecognizedAttribs) return false;

        return true;
    }
    bool operator!=(const SOP_AttribScanParms &src) const
    {
        return !operator==(src);
    }
    using Attribowner = SOP_AttribScanEnums::Attribowner;
    using Attribtype = SOP_AttribScanEnums::Attribtype;
    using Method = SOP_AttribScanEnums::Method;



    void        buildFromOp(const SOP_GraphProxy *graph, exint nodeidx, fpreal time, DEP_MicroNode *depnode)
    {
        myPtscan = ""_sh;
        if (true)
            graph->evalOpParm(myPtscan, nodeidx, "ptscan", time, 0);
        myPrimscan = ""_sh;
        if (true)
            graph->evalOpParm(myPrimscan, nodeidx, "primscan", time, 0);
        myVtxscan = ""_sh;
        if (true)
            graph->evalOpParm(myVtxscan, nodeidx, "vtxscan", time, 0);
        myDtlscan = ""_sh;
        if (true)
            graph->evalOpParm(myDtlscan, nodeidx, "dtlscan", time, 0);
        if (true)
        {
            int64   length = 0;
            graph->evalOpParm(length, nodeidx, "recognizedattribs", time, 0);
            if (length < 0) length = 0;
            myRecognizedAttribs.setSize(length);
            for (exint i = 0; i < length; i++)
            {
                int     parmidx[1];
                int     offsets[1];
                parmidx[0] = i+1;
                offsets[0] = 1;
                auto && _curentry = myRecognizedAttribs(i);
                (void) _curentry;
                _curentry.attribname = ""_sh;
                if (true)
                    graph->evalOpParmInst(_curentry.attribname, nodeidx, "attribname#", parmidx, offsets, time, 0, 2-1);
                _curentry.attribowner = 0;
                if (true)
                    graph->evalOpParmInst(_curentry.attribowner, nodeidx, "attribowner#", parmidx, offsets, time, 0, 2-1);
                _curentry.attribtype = 0;
                if (true)
                    graph->evalOpParmInst(_curentry.attribtype, nodeidx, "attribtype#", parmidx, offsets, time, 0, 2-1);
                _curentry.ensurevalue = false;
                if (true && ( (true&&!(((_curentry.attribtype==6))||((_curentry.attribtype==7))||((_curentry.attribtype==8))||((_curentry.attribtype==9)))) ) )
                    graph->evalOpParmInst(_curentry.ensurevalue, nodeidx, "ensurevalue#", parmidx, offsets, time, 0, 2-1);
                _curentry.floatval = 0;
                if (true && ( (true&&!(((_curentry.ensurevalue==0))||((_curentry.attribtype!=0)))) ) )
                    graph->evalOpParmInst(_curentry.floatval, nodeidx, "floatval#", parmidx, offsets, time, 0, 2-1);
                _curentry.intval = 0;
                if (true && ( (true&&!(((_curentry.ensurevalue==0))||((_curentry.attribtype!=1)))) ) )
                    graph->evalOpParmInst(_curentry.intval, nodeidx, "intval#", parmidx, offsets, time, 0, 2-1);
                _curentry.stringval = ""_sh;
                if (true && ( (true&&!(((_curentry.ensurevalue==0))||((_curentry.attribtype!=2)))) ) )
                    graph->evalOpParmInst(_curentry.stringval, nodeidx, "stringval#", parmidx, offsets, time, 0, 2-1);
                _curentry.vector2val = 0;
                if (true && ( (true&&!(((_curentry.ensurevalue==0))||((_curentry.attribtype!=3)))) ) )
                    graph->evalOpParmInst(_curentry.vector2val, nodeidx, "vector2val#", parmidx, offsets, time, 0, 2-1);
                _curentry.vector3val = 0;
                if (true && ( (true&&!(((_curentry.ensurevalue==0))||((_curentry.attribtype!=4)))) ) )
                    graph->evalOpParmInst(_curentry.vector3val, nodeidx, "vector3val#", parmidx, offsets, time, 0, 2-1);
                _curentry.vector4val = 0;
                if (true && ( (true&&!(((_curentry.ensurevalue==0))||((_curentry.attribtype!=5)))) ) )
                    graph->evalOpParmInst(_curentry.vector4val, nodeidx, "vector4val#", parmidx, offsets, time, 0, 2-1);
                _curentry.method = 0;
                if (true && ( (true&&!(((_curentry.ensurevalue==0))||((_curentry.attribtype==6))||((_curentry.attribtype==7))||((_curentry.attribtype==8))||((_curentry.attribtype==9)))) ) )
                    graph->evalOpParmInst(_curentry.method, nodeidx, "method#", parmidx, offsets, time, 0, 2-1);

            }
        }
        else
            myRecognizedAttribs.clear();

    }


    void loadFromOpSubclass(const LoadParms &loadparms) override
    {
        buildFromOp(loadparms.graph(), loadparms.nodeIdx(), loadparms.context().getTime(), loadparms.depnode());
    }


    void copyFrom(const SOP_NodeParms *src) override
    {
        *this = *((const SOP_AttribScanParms *)src);
    }

    template <typename T>
    void
    doGetParmValue(TempIndex idx, TempIndex instance, T &value) const
    {
        if (idx.size() < 1)
            return;
        UT_ASSERT(idx.size() == instance.size()+1);
        if (idx.size() != instance.size()+1)
            return;
        switch (idx[0])
        {
            case 0:
                coerceValue(value, myPtscan);
                break;
            case 1:
                coerceValue(value, myPrimscan);
                break;
            case 2:
                coerceValue(value, myVtxscan);
                break;
            case 3:
                coerceValue(value, myDtlscan);
                break;
            case 4:
                if (idx.size() == 1)
                    coerceValue(value, myRecognizedAttribs.entries());
                else if (instance[0] < myRecognizedAttribs.entries())
                {
                    auto && _data = myRecognizedAttribs(instance[0]);
                    switch (idx[1])
                    {
                    case 0:
                        coerceValue(value, _data.attribname);
                        break;
                    case 1:
                        coerceValue(value, _data.attribowner);
                        break;
                    case 2:
                        coerceValue(value, _data.attribtype);
                        break;
                    case 3:
                        coerceValue(value, _data.ensurevalue);
                        break;
                    case 4:
                        coerceValue(value, _data.floatval);
                        break;
                    case 5:
                        coerceValue(value, _data.intval);
                        break;
                    case 6:
                        coerceValue(value, _data.stringval);
                        break;
                    case 7:
                        coerceValue(value, _data.vector2val);
                        break;
                    case 8:
                        coerceValue(value, _data.vector3val);
                        break;
                    case 9:
                        coerceValue(value, _data.vector4val);
                        break;
                    case 10:
                        coerceValue(value, _data.method);
                        break;

                    }
                }
                break;

        }
    }

    void getNestParmValue(TempIndex idx, TempIndex instance, exint &value) const override
    { doGetParmValue(idx, instance, value); }
    void getNestParmValue(TempIndex idx, TempIndex instance, fpreal &value) const override
    { doGetParmValue(idx, instance, value); }
    void getNestParmValue(TempIndex idx, TempIndex instance, UT_Vector2D &value) const override
    { doGetParmValue(idx, instance, value); }
    void getNestParmValue(TempIndex idx, TempIndex instance, UT_Vector3D &value) const override
    { doGetParmValue(idx, instance, value); }
    void getNestParmValue(TempIndex idx, TempIndex instance, UT_Vector4D &value) const override
    { doGetParmValue(idx, instance, value); }
    void getNestParmValue(TempIndex idx, TempIndex instance, UT_Matrix2D &value) const override
    { doGetParmValue(idx, instance, value); }
    void getNestParmValue(TempIndex idx, TempIndex instance, UT_Matrix3D &value) const override
    { doGetParmValue(idx, instance, value); }
    void getNestParmValue(TempIndex idx, TempIndex instance, UT_Matrix4D &value) const override
    { doGetParmValue(idx, instance, value); }
    void getNestParmValue(TempIndex idx, TempIndex instance, UT_StringHolder &value) const override
    { doGetParmValue(idx, instance, value); }
    void getNestParmValue(TempIndex idx, TempIndex instance, UT_SharedPtr<UT_Ramp> &value) const override
    { doGetParmValue(idx, instance, value); }
    void getNestParmValue(TempIndex idx, TempIndex instance, PRM_DataItemHandle &value) const override
    { doGetParmValue(idx, instance, value); }

    template <typename T>
    void
    doSetParmValue(TempIndex idx, TempIndex instance, const T &value) 
    {
        if (idx.size() < 1)
            return;
        UT_ASSERT(idx.size() == instance.size()+1);
        if (idx.size() != instance.size()+1)
            return;
        switch (idx[0])
        {
            case 0:
                coerceValue(myPtscan, ( ( value ) ));
                break;
            case 1:
                coerceValue(myPrimscan, ( ( value ) ));
                break;
            case 2:
                coerceValue(myVtxscan, ( ( value ) ));
                break;
            case 3:
                coerceValue(myDtlscan, ( ( value ) ));
                break;
            case 4:
                if (idx.size() == 1)
                {
                    exint       newsize;
                    coerceValue(newsize, value);
                    if (newsize < 0) newsize = 0;
                    myRecognizedAttribs.setSize(newsize);
                }
                else
                {
                    if (instance[0] < 0)
                        return;
                    myRecognizedAttribs.setSizeIfNeeded(instance[0]+1);
                    auto && _data = myRecognizedAttribs(instance[0]);
                    switch (idx[1])
                    {
                    case 0:
                        coerceValue(_data.attribname, value);
                        break;
                    case 1:
                        coerceValue(_data.attribowner, value);
                        break;
                    case 2:
                        coerceValue(_data.attribtype, value);
                        break;
                    case 3:
                        coerceValue(_data.ensurevalue, value);
                        break;
                    case 4:
                        coerceValue(_data.floatval, value);
                        break;
                    case 5:
                        coerceValue(_data.intval, value);
                        break;
                    case 6:
                        coerceValue(_data.stringval, value);
                        break;
                    case 7:
                        coerceValue(_data.vector2val, value);
                        break;
                    case 8:
                        coerceValue(_data.vector3val, value);
                        break;
                    case 9:
                        coerceValue(_data.vector4val, value);
                        break;
                    case 10:
                        coerceValue(_data.method, value);
                        break;

                    }
                }
                break;

        }
    }

    void setNestParmValue(TempIndex idx, TempIndex instance, const exint &value)  override
    { doSetParmValue(idx, instance, value); }
    void setNestParmValue(TempIndex idx, TempIndex instance, const fpreal &value)  override
    { doSetParmValue(idx, instance, value); }
    void setNestParmValue(TempIndex idx, TempIndex instance, const UT_Vector2D &value)  override
    { doSetParmValue(idx, instance, value); }
    void setNestParmValue(TempIndex idx, TempIndex instance, const UT_Vector3D &value)  override
    { doSetParmValue(idx, instance, value); }
    void setNestParmValue(TempIndex idx, TempIndex instance, const UT_Vector4D &value)  override
    { doSetParmValue(idx, instance, value); }
    void setNestParmValue(TempIndex idx, TempIndex instance, const UT_Matrix2D &value)  override
    { doSetParmValue(idx, instance, value); }
    void setNestParmValue(TempIndex idx, TempIndex instance, const UT_Matrix3D &value)  override
    { doSetParmValue(idx, instance, value); }
    void setNestParmValue(TempIndex idx, TempIndex instance, const UT_Matrix4D &value)  override
    { doSetParmValue(idx, instance, value); }
    void setNestParmValue(TempIndex idx, TempIndex instance, const UT_StringHolder &value)  override
    { doSetParmValue(idx, instance, value); }
    void setNestParmValue(TempIndex idx, TempIndex instance, const UT_SharedPtr<UT_Ramp> &value)  override
    { doSetParmValue(idx, instance, value); }
    void setNestParmValue(TempIndex idx, TempIndex instance, const PRM_DataItemHandle &value)  override
    { doSetParmValue(idx, instance, value); }

    exint getNestNumParms(TempIndex idx) const override
    {
        if (idx.size() == 0)
            return 5;
        switch (idx[0])
        {
            case 4:
                return 11;

        }
        // Invalid
        return 0;
    }

    const char *getNestParmName(TempIndex fieldnum) const override
    {
        if (fieldnum.size() < 1)
            return 0;
        switch (fieldnum[0])
        {
            case 0:
                return "ptscan";
            case 1:
                return "primscan";
            case 2:
                return "vtxscan";
            case 3:
                return "dtlscan";
            case 4:
                if (fieldnum.size() == 1)
                    return "recognizedattribs";
                switch (fieldnum[1])
                {
                    case 0:
                        return "attribname#";
                    case 1:
                        return "attribowner#";
                    case 2:
                        return "attribtype#";
                    case 3:
                        return "ensurevalue#";
                    case 4:
                        return "floatval#";
                    case 5:
                        return "intval#";
                    case 6:
                        return "stringval#";
                    case 7:
                        return "vector2val#";
                    case 8:
                        return "vector3val#";
                    case 9:
                        return "vector4val#";
                    case 10:
                        return "method#";

                }
                return 0;

        }
        return 0;
    }

    ParmType getNestParmType(TempIndex fieldnum) const override
    {
        if (fieldnum.size() < 1)
            return PARM_UNSUPPORTED;
        switch (fieldnum[0])
        {
            case 0:
                return PARM_STRING;
            case 1:
                return PARM_STRING;
            case 2:
                return PARM_STRING;
            case 3:
                return PARM_STRING;
            case 4:
                if (fieldnum.size() == 1)
                    return PARM_MULTIPARM;
                switch (fieldnum[1])
                {
                    case 0:
                        return PARM_STRING;
                    case 1:
                        return PARM_INTEGER;
                    case 2:
                        return PARM_INTEGER;
                    case 3:
                        return PARM_INTEGER;
                    case 4:
                        return PARM_FLOAT;
                    case 5:
                        return PARM_INTEGER;
                    case 6:
                        return PARM_STRING;
                    case 7:
                        return PARM_VECTOR2;
                    case 8:
                        return PARM_VECTOR3;
                    case 9:
                        return PARM_VECTOR4;
                    case 10:
                        return PARM_INTEGER;

                }
                return PARM_UNSUPPORTED;

        }
        return PARM_UNSUPPORTED;
    }

    // Boiler plate to load individual types.
    static void  loadData(UT_IStream &is, int64 &v)
    { is.bread(&v, 1); }
    static void  loadData(UT_IStream &is, bool &v)
    { int64     iv; is.bread(&iv, 1); v = iv; }
    static void  loadData(UT_IStream &is, fpreal64 &v)
    { is.bread<fpreal64>(&v, 1); }
    static void  loadData(UT_IStream &is, UT_Vector2D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4D &v)
    { is.bread<fpreal64>(&v.x(), 1); is.bread<fpreal64>(&v.y(), 1);
      is.bread<fpreal64>(&v.z(), 1); is.bread<fpreal64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix2D &v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix3D &v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Matrix4D &v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) is.bread<fpreal64>(&v(r, c), 1); }
    static void  loadData(UT_IStream &is, UT_Vector2I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector3I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); }
    static void  loadData(UT_IStream &is, UT_Vector4I &v)
    { is.bread<int64>(&v.x(), 1); is.bread<int64>(&v.y(), 1);
      is.bread<int64>(&v.z(), 1); is.bread<int64>(&v.w(), 1); }
    static void  loadData(UT_IStream &is, UT_StringHolder &v)
    { is.bread(v); }
    static void  loadData(UT_IStream &is, UT_SharedPtr<UT_Ramp> &v)
    {   UT_StringHolder   rampdata;
        loadData(is, rampdata);
        if (rampdata.isstring())
        {
            v.reset(new UT_Ramp());
            UT_IStream  istr((const char *) rampdata, rampdata.length(), UT_ISTREAM_ASCII);
            v->load(istr);
        }
        else v.reset();
    }
    static void  loadData(UT_IStream &is, PRM_DataItemHandle &v)
    {   UT_StringHolder   data;
        loadData(is, data);
        if (data.isstring())
        {
            // Find the data type.
            const char *colon = UT_StringWrap(data).findChar(':');
            if (colon)
            {
                int             typelen = colon - data.buffer();
                UT_WorkBuffer   type;
                type.strncpy(data.buffer(), typelen);
                UT_IStream  istr(((const char *) data) + typelen + 1, data.length() - (typelen + 1), UT_ISTREAM_BINARY);
                
                v = PRM_DataFactory::parseBinary(type.buffer(), istr);
            }
        }
        else v.reset();
    }

    static void  saveData(std::ostream &os, int64 v)
    { UTwrite(os, &v); }
    static void  saveData(std::ostream &os, bool v)
    { int64 iv = v; UTwrite(os, &iv); }
    static void  saveData(std::ostream &os, fpreal64 v)
    { UTwrite<fpreal64>(os, &v); }
    static void  saveData(std::ostream &os, UT_Vector2D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y()); }
    static void  saveData(std::ostream &os, UT_Vector3D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); }
    static void  saveData(std::ostream &os, UT_Vector4D v)
    { UTwrite<fpreal64>(os, &v.x()); UTwrite<fpreal64>(os, &v.y());
      UTwrite<fpreal64>(os, &v.z()); UTwrite<fpreal64>(os, &v.w()); }
    static void  saveData(std::ostream &os, UT_Matrix2D v)
    { for (int r = 0; r < 2; r++) for (int c = 0; c < 2; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix3D v)
    { for (int r = 0; r < 3; r++) for (int c = 0; c < 3; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_Matrix4D v)
    { for (int r = 0; r < 4; r++) for (int c = 0; c < 4; c++) UTwrite<fpreal64>(os, &v(r, c)); }
    static void  saveData(std::ostream &os, UT_StringHolder s)
    { UT_StringWrap(s).saveBinary(os); }
    static void  saveData(std::ostream &os, UT_SharedPtr<UT_Ramp> s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) s->save(ostr);
        result = ostr.str();
        saveData(os, result);
    }
    static void  saveData(std::ostream &os, PRM_DataItemHandle s)
    {   UT_StringHolder         result;
        UT_OStringStream        ostr;
        if (s) 
        {
            ostr << s->getDataTypeToken();
            ostr << ":";
            s->saveBinary(ostr);
        }
        result = ostr.str();
        saveData(os, result);
    }


    void         save(std::ostream &os) const
    {
        int32           v = version();
        UTwrite(os, &v);
        saveData(os, myPtscan);
        saveData(os, myPrimscan);
        saveData(os, myVtxscan);
        saveData(os, myDtlscan);
        {
            int64   length = myRecognizedAttribs.entries();
            UTwrite(os, &length);
            for (exint i = 0; i < length; i++)
            {
                auto && _curentry = myRecognizedAttribs(i);
                (void) _curentry;
                saveData(os, _curentry.attribname);
                saveData(os, _curentry.attribowner);
                saveData(os, _curentry.attribtype);
                saveData(os, _curentry.ensurevalue);
                saveData(os, _curentry.floatval);
                saveData(os, _curentry.intval);
                saveData(os, _curentry.stringval);
                saveData(os, _curentry.vector2val);
                saveData(os, _curentry.vector3val);
                saveData(os, _curentry.vector4val);
                saveData(os, _curentry.method);

            }
        }

    }

    bool         load(UT_IStream &is)
    {
        int32           v;
        is.bread(&v, 1);
        if (version() != v)
        {
            // Fail incompatible versions
            return false;
        }
        loadData(is, myPtscan);
        loadData(is, myPrimscan);
        loadData(is, myVtxscan);
        loadData(is, myDtlscan);
        {
            int64   length;
            is.read(&length, 1);
            myRecognizedAttribs.setSize(length);
            for (exint i = 0; i < length; i++)
            {
                auto && _curentry = myRecognizedAttribs(i);
                (void) _curentry;
                loadData(is, _curentry.attribname);
                loadData(is, _curentry.attribowner);
                loadData(is, _curentry.attribtype);
                loadData(is, _curentry.ensurevalue);
                loadData(is, _curentry.floatval);
                loadData(is, _curentry.intval);
                loadData(is, _curentry.stringval);
                loadData(is, _curentry.vector2val);
                loadData(is, _curentry.vector3val);
                loadData(is, _curentry.vector4val);
                loadData(is, _curentry.method);

            }
        }

        return true;
    }

    const UT_StringHolder & getPtscan() const { return myPtscan; }
    void setPtscan(const UT_StringHolder & val) { myPtscan = val; }
    UT_StringHolder opPtscan(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPtscan();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "ptscan", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getPrimscan() const { return myPrimscan; }
    void setPrimscan(const UT_StringHolder & val) { myPrimscan = val; }
    UT_StringHolder opPrimscan(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getPrimscan();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "primscan", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getVtxscan() const { return myVtxscan; }
    void setVtxscan(const UT_StringHolder & val) { myVtxscan = val; }
    UT_StringHolder opVtxscan(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getVtxscan();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "vtxscan", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_StringHolder & getDtlscan() const { return myDtlscan; }
    void setDtlscan(const UT_StringHolder & val) { myDtlscan = val; }
    UT_StringHolder opDtlscan(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getDtlscan();
        UT_StringHolder result;
        OP_Utils::evalOpParm(result, thissop, "dtlscan", cookparms.getCookTime(), 0);
        return result;
    }
    const UT_Array<RecognizedAttribs> &getRecognizedAttribs() const { return myRecognizedAttribs; }
void setRecognizedAttribs(const UT_Array<RecognizedAttribs> &val) { myRecognizedAttribs = val; }
    exint opRecognizedAttribs(const SOP_NodeVerb::CookParms &cookparms) const
    { 
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return getRecognizedAttribs().entries();
        exint result;
        OP_Utils::evalOpParm(result, thissop, "recognizedattribs", cookparms.getCookTime(), 0);
        return result;
    }
        UT_StringHolder opRecognizedAttribs_attribname(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_attribname(cookparms, &_idx); }
    UT_StringHolder opinstRecognizedAttribs_attribname(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).attribname);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        UT_StringHolder result;
        OP_Utils::evalOpParmInst(result, thissop, "attribname#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }
    int64 opRecognizedAttribs_attribowner(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_attribowner(cookparms, &_idx); }
    int64 opinstRecognizedAttribs_attribowner(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).attribowner);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        int64 result;
        OP_Utils::evalOpParmInst(result, thissop, "attribowner#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }
    int64 opRecognizedAttribs_attribtype(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_attribtype(cookparms, &_idx); }
    int64 opinstRecognizedAttribs_attribtype(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).attribtype);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        int64 result;
        OP_Utils::evalOpParmInst(result, thissop, "attribtype#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }
    bool opRecognizedAttribs_ensurevalue(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_ensurevalue(cookparms, &_idx); }
    bool opinstRecognizedAttribs_ensurevalue(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).ensurevalue);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        bool result;
        OP_Utils::evalOpParmInst(result, thissop, "ensurevalue#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }
    fpreal64 opRecognizedAttribs_floatval(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_floatval(cookparms, &_idx); }
    fpreal64 opinstRecognizedAttribs_floatval(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).floatval);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        fpreal64 result;
        OP_Utils::evalOpParmInst(result, thissop, "floatval#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }
    int64 opRecognizedAttribs_intval(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_intval(cookparms, &_idx); }
    int64 opinstRecognizedAttribs_intval(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).intval);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        int64 result;
        OP_Utils::evalOpParmInst(result, thissop, "intval#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }
    UT_StringHolder opRecognizedAttribs_stringval(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_stringval(cookparms, &_idx); }
    UT_StringHolder opinstRecognizedAttribs_stringval(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).stringval);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        UT_StringHolder result;
        OP_Utils::evalOpParmInst(result, thissop, "stringval#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }
    UT_Vector2D opRecognizedAttribs_vector2val(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_vector2val(cookparms, &_idx); }
    UT_Vector2D opinstRecognizedAttribs_vector2val(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).vector2val);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        UT_Vector2D result;
        OP_Utils::evalOpParmInst(result, thissop, "vector2val#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }
    UT_Vector3D opRecognizedAttribs_vector3val(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_vector3val(cookparms, &_idx); }
    UT_Vector3D opinstRecognizedAttribs_vector3val(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).vector3val);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        UT_Vector3D result;
        OP_Utils::evalOpParmInst(result, thissop, "vector3val#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }
    UT_Vector4D opRecognizedAttribs_vector4val(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_vector4val(cookparms, &_idx); }
    UT_Vector4D opinstRecognizedAttribs_vector4val(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).vector4val);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        UT_Vector4D result;
        OP_Utils::evalOpParmInst(result, thissop, "vector4val#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }
    int64 opRecognizedAttribs_method(const SOP_NodeVerb::CookParms &cookparms, int _idx) const
    { return opinstRecognizedAttribs_method(cookparms, &_idx); }
    int64 opinstRecognizedAttribs_method(const SOP_NodeVerb::CookParms &cookparms, const int *_idx) const
    {
        SOP_Node *thissop = cookparms.getNode();
        if (!thissop) return (myRecognizedAttribs(_idx[0]).method);
        int _parmidx[2-1];
        _parmidx[1-1] = _idx[1-1] + 1;

        int64 result;
        OP_Utils::evalOpParmInst(result, thissop, "method#", _parmidx, cookparms.getCookTime(), 0, 2-1);
        return (result);
    }


private:
    UT_StringHolder myPtscan;
    UT_StringHolder myPrimscan;
    UT_StringHolder myVtxscan;
    UT_StringHolder myDtlscan;
    UT_Array<RecognizedAttribs> myRecognizedAttribs;

};
